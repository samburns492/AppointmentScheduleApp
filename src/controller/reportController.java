package controller;
import java.io.IOException;
import java.net.URL;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.TableCell;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.control.TableView;
import schedulingapp.model.Customer;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TextArea;
import javafx.stage.Stage;
import schedulingapp.DAO.AppointmentDaoImpl;
import schedulingapp.DAO.ContactDaoImpl;
import static schedulingapp.DAO.ContactDaoImpl.getContactByName;
import schedulingapp.DAO.ReportDaoImpl;
import static schedulingapp.DAO.ReportDaoImpl.getAllReportsByMonthContact;
import schedulingapp.model.Appointment;
import schedulingapp.model.Contact;
import schedulingapp.model.Report;

/**
 * Creates a controller class for the report form of the Scheduling application. This controller
 * handles all three reports generated by contact in the system.
 * @author Sam
 */

public class reportController implements Initializable {
    
    public TableView<Report> reportTable;
    public TableColumn monthCol;
    public TableColumn typeCol;
    public TableColumn countCol;
    
    public TableView<Appointment> appointTable;
    public TableColumn apptTableId;
    public TableColumn apptTableTitle;
    public TableColumn apptTableDesc;
    public TableColumn apptTableType;
    public TableColumn <Appointment, LocalDateTime> apptTableStDt;
    public TableColumn <Appointment, LocalDateTime> apptTableEdDt;
    public TableColumn apptTableCusId;
    
    

    @FXML private ChoiceBox contactSelect;
    @FXML private TextArea textArea;
    
    
    public ObservableList<Report> reports = FXCollections.observableArrayList();
    public ObservableList<Report> reports2 = FXCollections.observableArrayList();
    public ObservableList<Appointment> appointsrpt = FXCollections.observableArrayList();
    
    /** Method initializes the main form and sets the data for all elements in the FXML file.
     * The method also formats the two tableviews with appointment and customer object data as
     * appropriate. It also uses three separate lambda expressions to format the incoming localdatetime
     * variables to display them as text in the table view. This is done for a string representing the 
     * month in the contact table and then the start and end date in a full "yyyy-MM-dd hh:mm:ss a" 
     * string in the appointment table. 
     * 
     * This is also where the program evaluates all appointments by selected contact and generates
     * a total by month. This is done with hashmap to determine unique appointment type and then all contacts 
     * are searched by month to count total type by month. The code is a nested for-loop and takes a long time
     * to run. 
     * 
     * In addition to the per contact appointment schedule and type count by month the third report is a display 
     * of the next upcoming appointment for the contact. The report goes through all appointments and determines
     * the next upcoming appointment for the selected contact. If no appointment is found the text area displays
     * "no upcoming appointment."
     * 
     * The use of each lambda is described here 
     * 1. The first lambda expression sets a cell factory on the month column which
     * converts a month integer to a string of that month from an array. This improves efficiency
     * because it only requires the code to be declared once within in the method.
     * 2. The second lambda expression to modify turn the localdatetime into a string for each row 
     * of the appointment start date column of contact schedule report. Increases efficiency by 
     * preventing the need to write the code in a separate class file. 
     * 3. The third lambda expression sets a cell factory on the end date column of the contact schedule
     * appointment tableview which serves as the contact schedule report. This expression
     * improves efficiency because the code is more readable with regards to how the interface handles
     * objects. 
     * 
     * @param arg0 URL variable
     * @param arg1 resource bundle object
     */
    
    public void initialize(URL arg0, ResourceBundle arg1) {
        
        ArrayList<String> months = new ArrayList<String>();
        months.add("Januay");
        months.add("February");
        months.add("March");
        months.add("April");
        months.add("May");
        months.add("June");
        months.add("July");
        months.add("August");
        months.add("September");
        months.add("October");
        months.add("November");
        months.add("December");
        
        monthCol.setCellValueFactory(new PropertyValueFactory<Customer,String>("month"));
        typeCol.setCellValueFactory(new PropertyValueFactory<Customer,String>("type"));
        countCol.setCellValueFactory(new PropertyValueFactory<Customer,String>("count"));
        
        apptTableId.setCellValueFactory(new PropertyValueFactory<Appointment,Integer>("appointmentID"));
        apptTableTitle.setCellValueFactory(new PropertyValueFactory<Appointment,String>("title"));
        apptTableDesc.setCellValueFactory(new PropertyValueFactory<Appointment,String>("description"));
        apptTableType.setCellValueFactory(new PropertyValueFactory<Appointment,String>("type"));
        apptTableCusId.setCellValueFactory(new PropertyValueFactory<Appointment,String>("customerName"));
        apptTableStDt.setCellValueFactory(new PropertyValueFactory<Appointment, LocalDateTime>("start"));
        apptTableEdDt.setCellValueFactory(new PropertyValueFactory<Appointment, LocalDateTime>("end"));
        
        DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss a");
       
        //lambda expression #1 which sets a cell facotry on the month column of the type by month tableview
        monthCol.setCellFactory(col -> new TableCell<Report, Integer>()
            {
                public void updateItem(Integer month, boolean empty) {
                    super.updateItem(month, empty);
                    
                    if (month == null) {
                       setText(null);
                    } else {
                        setText(months.get(month - 1));
                    }
                    
                }
        });
        
        //lambda expression #2 which sets a cell factory on the appointment start date column of the contact schedule tableview
        apptTableStDt.setCellFactory(col -> new TableCell<Appointment, LocalDateTime>()
            {
                public void updateItem(LocalDateTime date, boolean empty) {
                    super.updateItem(date, empty);
                    
                    if (date == null) {
                       setText(null);
                    } else {
                        setText(dateFormat.format(date));
                    }
                    
                }
        });
        
        //lambda expression #3 which sets a cell factory on the appointment end date column of the contact schedule tableview 
        apptTableEdDt.setCellFactory(col -> new TableCell<Appointment, LocalDateTime>()
            {
                public void updateItem(LocalDateTime date, boolean empty) {
                    super.updateItem(date, empty);
                    
                    if (date == null) {
                       setText(null);
                    } else {
                        setText(dateFormat.format(date));
                    }
                    
                }
        });
        
        try {
            ObservableList<Contact> contlist = ContactDaoImpl.getAllContacts();
            ObservableList<String> stringContact = FXCollections.observableArrayList();
            
            for (Contact C : contlist)
            {
                stringContact.add(C.getContactName());
            } 
            
            contactSelect.setItems(stringContact);
        } catch (Exception ex) {
            Logger.getLogger(mainformController.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        contactSelect.valueProperty().addListener((observable, oldlist, newcontact) -> {
            
            reportTable.getSelectionModel().clearSelection();
            reportTable.getItems().clear();
            
            appointTable.getSelectionModel().clearSelection();
            appointTable.getItems().clear();
            
            textArea.clear();
            
            boolean isComboEmpty = contactSelect.getSelectionModel().isEmpty();
            
                
               
            if(isComboEmpty != true) {
                    
                try {
            
                    reports.addAll(ReportDaoImpl.getAllReports());
                    
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
 
                    String strcontact = (String)contactSelect.getSelectionModel().getSelectedItem();
                    Contact tempcontact = getContactByName(strcontact);
                    int contact = tempcontact.getContactID();    
                    
                    ObservableList<Integer> intMonth = FXCollections.observableArrayList();
                    ObservableList<String> stringType = FXCollections.observableArrayList();
                    ObservableList<String> typename = FXCollections.observableArrayList();
                    HashMap<Integer, String> map = new HashMap<>();
                    ObservableList<Integer> typeCount = FXCollections.observableArrayList();
                    
                    for (Report R : reports)
                    {
                        int tempm = R.getMonth();
                        intMonth.add(tempm);
                        
                        String tempt = R.getType();
                        stringType.add(tempt);
                        map.put(tempm, tempt);
                    }
                    
                    Map<String, Long> reportMap = reports.stream().collect(Collectors.groupingBy(Report::getType, Collectors.counting()));
            
                    for (Map.Entry mapElement : reportMap.entrySet()) {
                        String key = (String)mapElement.getKey();
                        long countoftype = (long)mapElement.getValue();
                        int countType = Math.toIntExact(countoftype);
                        
                        typename.add(key);
                        typeCount.add(countType);
                        
                        for (int i = 0; i < 13; i++) {
                            int temp = getAllReportsByMonthContact(i, contact, key);
                            if (temp != 0) {
                                Report tempReport = new Report(contact, i, key, temp);
                                reports2.add(tempReport);
                                
                            }
                        }
                    }
           
                    reportTable.setItems(reports2);
                    
                    appointsrpt.addAll(AppointmentDaoImpl.getAllAppointmentsByContact(contact));
                    
                    LocalDateTime now = LocalDateTime.now();
                    LocalDateTime temp = now.plusYears((long) 1.0);
                    
                    for(Appointment A: appointsrpt) {
                        LocalDateTime ldt = A.getStart();
                        System.out.println(ldt);
                        if(ldt.isAfter(now) & ldt.isBefore(temp)) {
                            temp = ldt; 
                        }  
                    }
                    
                    if(temp.isEqual(now.plusYears((long) 1.0))) {
                        textArea.setText("No upcoming appointments");
                    } else {
                        textArea.setText(temp.format(formatter));
                    }
                    
                    appointTable.setItems(appointsrpt);
                        
                } catch (Exception err) {
                    err.printStackTrace();
                }           
            }
        });
    }
    
    /**
     * This method launches the mainform controller and accompanying fxml file. Basically
     * returns the user to previous screen.
     * @param actionEvent activated when user clicks the "back" button on the bottom right 
     * corner of the report pane. 
     * @throws IOException 
     */ 
    public void toMain(ActionEvent actionEvent) throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass().getResource("/view/mainform.fxml"));
        Parent root = loader.load();
        Stage stage = (Stage)((Node)actionEvent.getSource()).getScene().getWindow();
        Scene scene = new Scene(root);
        stage.setTitle("Scheduling App");
        stage.setScene(scene);
        stage.show();
    }
}
